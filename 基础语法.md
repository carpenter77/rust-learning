##### 打印

打印由std:fmt 定义的一系列宏所定义的。

```
可以在 `:` 后面指定特殊的格式
// `derive` 属性会自动创建所需的实现，使这个 `struct` 能使用 `fmt::Debug` 打印。
#[derive(Debug)]
但是 fmt::Display 需要手动实现。
```

内置类型标准库都Display和Debug的trait。

* Display {}来显示格式化文本
* Debug {:?} 格式化文本供调试使用。
  *  `{:#?}`，将struct类型像是json格式打印出来。
* 自定义类型需要自己实现Display的trait

rust格式化输出和python的风格很像。

**尝试打印一个List**

```
// 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。
// 否则（没有出错）继续执行后面的语句。
write!(f, "{}", value)?;
#[derive(Debug)]
struct List(Vec<i32>);
impl fmt::Display for List{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
       let vec=&self.0;
        write!(f,"[")?;
        for (ind,val) in vec.iter().enumerate(){
            if ind!=0{ write!(f,", ")?;}
            write!(f,"{}",val);
        }
        write!(f,"]")
    }
}
```

```
//通过使用前缀来表示 2进制、8进制、16进制的数；通过在后缀来表示是什么类型的数
println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
```

切点的大小在编译的时候是不确定的，内容包括了：类型指针和切片长度。

数据的大小是在栈中分配内存。

##### 枚举

```
// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]
//一个 `enum` 可以是单元结构体
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers; //实现取别名
enum Operator{
    Add,
    Sub{num1: i32,num2: i32},
    Mul(String),
    Divide,
}
//使用use，就不用写出完整的路径
//原本使用Operator::Add
use Operator::*;
//直接使用Add
match v {
        Operator::Add=> println!("{}",v),
        //Sub{xx,xx}名字必须要和Operator中定义的成员名要一样否则会报错
        Operator::Sub{num1,num2}=>{
            println!("x {}, y{}",x,y);
            },
    }
enum Number {
    Zero, //隐式从0 开始，也可以对enum 像是c一样直接赋值
    One = 1,
    Two,
}   
//可以将enum 直接转换成i32类型
println!("zero is {}", Number::Zero as i32);
```

```
enum List{
    Cons(i32,Box<List>),
    None,
}
impl List{
    fn new() ->List{
        return None;
    }
    fn preappend(self,val :i32) -> List{
        Cons(val, Box::new(self))
    }
    fn size(self :&List) -> u32{
        match *self{
            //self为引用时不能获取其所有权，只能获取引用
            Cons(_,ref tail)=> 1+ tail.size(),
            None=> return 0,
        }
    }
    fn string(self :&List)-> String{
        match *self {
            Cons(val,ref tail)=> format!("{}, {}",val,tail.string()),
            None => format!("")
        }
    }
}
fn main(){
    let mut lis=List::new();
    lis=lis.preappend(32);
    lis=lis.preappend(11);
    lis=lis.preappend(10);
    println!("lic size:{}",lis.size());
    println!("lic content:{}",lis.string());
}
```

##### 常量和变量

`const`：不可改变的值

`static`：具有 \`static生命周期的，可以是可变的变量（译注：须使用 `static mut` 关键字）

有个特例就是 `"string"` 字面量。它可以不经改动就被赋给一个 `static` 变量，因为它 的类型标记：`&'static str`

全局变量是在在所有其他作用域之外声明的	

Rust 通过静态类型确保类型安全，但是很多的时候编译器能够从上文知道声明的变量的类型，所以省去了许多变量声明的工作。

> ​	改正 ^ 在变量名前加上下划线以消除警告

* 变量绑定默认是不可变的（immutable），但加上 `mut` 修饰语后变量就可以改变。

* 变量的作用域被限制在代码块中，代码快的范围｛｝包围的集合
  * variable shadowing， 局部的变量名会覆盖隐藏外部范围的变量
* 编译器禁止使用未经初始化的变量，因为这会产生未定义行为（undefined behavior）。

* 当数据被相同的名称不变地绑定时，它还会**冻结**

  ```
  let mut _mutable_integer = 7i32;
      {
          // 被不可变的 `_mutable_integer` 遮蔽
          let _mutable_integer = _mutable_integer;
          // 报错！`_mutable_integer` 在本作用域被冻结
          _mutable_integer = 50;
          // 改正 ^ 注释掉上面这行
      }
      // 正常运行！ `_mutable_integer` 在这个作用域没有冻结
      _mutable_integer = 3;
  ```

  