##### 打印

打印由std:fmt 定义的一系列宏所定义的。

```
可以在 `:` 后面指定特殊的格式
// `derive` 属性会自动创建所需的实现，使这个 `struct` 能使用 `fmt::Debug` 打印。
#[derive(Debug)]
但是 fmt::Display 需要手动实现。
```

内置类型标准库都Display和Debug的trait。

* Display {}来显示格式化文本
* Debug {:?} 格式化文本供调试使用。
  *  `{:#?}`，将struct类型像是json格式打印出来。
* 自定义类型需要自己实现Display的trait

rust格式化输出和python的风格很像。

**尝试打印一个List**

```
// 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。
// 否则（没有出错）继续执行后面的语句。
write!(f, "{}", value)?;
#[derive(Debug)]
struct List(Vec<i32>);
impl fmt::Display for List{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
       let vec=&self.0;
        write!(f,"[")?;
        for (ind,val) in vec.iter().enumerate(){
            if ind!=0{ write!(f,", ")?;}
            write!(f,"{}",val);
        }
        write!(f,"]")
    }
}
```

```
//通过使用前缀来表示 2进制、8进制、16进制的数；通过在后缀来表示是什么类型的数
println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
```

切点的大小在编译的时候是不确定的，内容包括了：类型指针和切片长度。

数据的大小是在栈中分配内存。

##### 枚举

```
// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]
//一个 `enum` 可以是单元结构体
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers; //实现取别名
enum Operator{
    Add,
    Sub{num1: i32,num2: i32},
    Mul(String),
    Divide,
}
//使用use，就不用写出完整的路径
//原本使用Operator::Add
use Operator::*;
//直接使用Add
match v {
        Operator::Add=> println!("{}",v),
        //Sub{xx,xx}名字必须要和Operator中定义的成员名要一样否则会报错
        Operator::Sub{num1,num2}=>{
            println!("x {}, y{}",x,y);
            },
    }
enum Number {
    Zero, //隐式从0 开始，也可以对enum 像是c一样直接赋值
    One = 1,
    Two,
}   
//可以将enum 直接转换成i32类型
println!("zero is {}", Number::Zero as i32);
```

```
enum List{
    Cons(i32,Box<List>),
    None,
}
impl List{
    fn new() ->List{
        return None;
    }
    fn preappend(self,val :i32) -> List{
        Cons(val, Box::new(self))
    }
    fn size(self :&List) -> u32{
        match *self{
            //self为引用时不能获取其所有权，只能获取引用
            Cons(_,ref tail)=> 1+ tail.size(),
            None=> return 0,
        }
    }
    fn string(self :&List)-> String{
        match *self {
            Cons(val,ref tail)=> format!("{}, {}",val,tail.string()),
            None => format!("")
        }
    }
}
fn main(){
    let mut lis=List::new();
    lis=lis.preappend(32);
    lis=lis.preappend(11);
    lis=lis.preappend(10);
    println!("lic size:{}",lis.size());
    println!("lic content:{}",lis.string());
}
```

##### 常量和变量

`const`：不可改变的值

`static`：具有 \`static生命周期的，可以是可变的变量（译注：须使用 `static mut` 关键字）

有个特例就是 `"string"` 字面量。它可以不经改动就被赋给一个 `static` 变量，因为它 的类型标记：`&'static str`

全局变量是在在所有其他作用域之外声明的	

Rust 通过静态类型确保类型安全，但是很多的时候编译器能够从上文知道声明的变量的类型，所以省去了许多变量声明的工作。

> ​	改正 ^ 在变量名前加上下划线以消除警告

* 变量绑定默认是不可变的（immutable），但加上 `mut` 修饰语后变量就可以改变。

* 变量的作用域被限制在代码块中，代码快的范围｛｝包围的集合
  
  * variable shadowing， 局部的变量名会覆盖隐藏外部范围的变量
* 编译器禁止使用未经初始化的变量，因为这会产生未定义行为（undefined behavior）。

* 当数据被相同的名称不变地绑定时，它还会**冻结**

  ```
  let mut _mutable_integer = 7i32;
      {
          // 被不可变的 `_mutable_integer` 遮蔽
          let _mutable_integer = _mutable_integer;
          // 报错！`_mutable_integer` 在本作用域被冻结
          _mutable_integer = 50;
          // 改正 ^ 注释掉上面这行
      }
      // 正常运行！ `_mutable_integer` 在这个作用域没有冻结
      _mutable_integer = 3;
  ```

##### 类型系统

rust不提供隐式的转换，但是可以使用 `as` 关键字进行显 式类型转换。

```
let decimal = 65.4321_f32;
 // 错误！不提供隐式转换
let integer: u8 = decimal;
let f=3.32_f32;
let a = f as u8;
println!("{}",a);
```

从最低有效位（LSB，least significant bits）开始保留 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。

MSB 最高位和LSB 最低位，按日常书写习惯就是最左边一位和最右边一位。

```
println!("1000 as a u8 is : {}", (1000 as u8)); //字面量报错
//变量可以
let num=1000;
println!("1000 as a u8 is : {}", (num as u8)); 
println!("1000 as a u8 is : {}",    (1000 % 256)); //上面两者是等价的
```



* 定字面量 `42` 的 类型是 `i32`，只需要写 `42i32`。如果没有限制，编译器会对整数使用 `i32`，对浮点数使用 `f64`。

* 它不只是在初始化时看看右值的类型而已，它还会考察变量之后会怎样使用，借此推断类型。

  ```
  // 因为有类型说明，编译器知道 `elem` 的类型是 u8。
  let elem = 5u8;
  // 创建一个空向量（vector，即不定长的，可以增长的数组）。
  let mut vec = Vec::new();
  // 现在编译器还不知道 `vec` 的具体类型，只知道它是某种东西构成的向量（`Vec<_>`）
  // 在向量中插入 `elem`。
  vec.push(elem);
  // 啊哈！现在编译器知道 `vec` 是 u8 的向量了（`Vec<u8>`）。
  println!("{:?}", vec);
  //若是没有push操作的话，cannot infer type for type parameter `T`
  ```

* 取别名

  ```
  // `NanoSecond` 是 `u64` 的新名字。
  type NanoSecond = u64;
  //类型的名字必须遵循驼峰命名法
  // 通过这个属性屏蔽警告。
  #[allow(non_camel_case_types)]
  type u64_t = u64;	
  ```

##### 类型转换

rust使用trait来解决类型转换的问题，From和into两个trait。

它的基本的理念： 若是能够从B转换到A，那也能够从A 转换回B。

* from trait 类型定义

怎么根据另一种类型生成自己，比如：let my_str = "hello"; let my_string = String::from(my_str);

```
use std::convert::From;
//最长用在自己定义的类型上
#[derive(Debug)]
struct Number {
    value: i32,
}
impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}
fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}
```

* into trait就是从from trait颠倒过来，若是实现了from trait ，也就自动获得了into trait

//Into 可以比喻为将值放到需要的结构体中

```
 let int = 5;
 let num: Number = int.into(); //若是删除了Number类型声明giving `num` a type
 println!("My number is {:?}", num);
```

* `TryFrom` 和 `TryInto` trait 用于易出错的转换，它的返回值是Result

  ```
   let result: Result<EvenNumber, ()> = 8i32.try_into();
   assert_eq!(result, Ok(EvenNumber(8)));
  ```

* 将自定义类型转换为String ,需要实现ToString trait。实现现[`fmt::Display` trait，它会自动提供 `ToString` trait。

* 字符串和数字的转换

  * 只要实现FromStr trait，都可以直接调用字符串的parse解析。一般的内置的类型都被标准库实现了。
  * 用户自定义的需要自己去实现FromStr trait。

  ```
  let parsed: i32 = "5".parse().unwrap();
  let turbo_parsed = "10".parse::<i32>().unwrap();
  format!("{}", num);//将数字转换成字符串
  ```

* 代码块也可以有返回值

  ```
  //如果代码块最后一条表达式结尾处有分号，那 么返回值将变成 ()
  //let x={}代码块最后一行作为返回值
  ```

##### 流程控制

* loop {} : 可以使用 `break` 语句在任何时候退出一个循环，另外可用 `continue` 跳过循环体的剩 余部分并开始下一轮循环。

  * 借助标签来处理嵌套循环的时候可以 `break` 或 `continue` 外层循环。
  * let val=loop{ break xx;} break可以返回一个值给loop的左值

* for 循环： `for in` 结构可以遍历一个 `Iterator`（迭代器。用区间标记 `a..b` 但是 不包括a和b。

  * 使用`a..=b`表示两端都包含在内的范围

  * for in 相当于会调用集合的 `into_iter` 函数。另外还有`iter` 和 `iter_mut` 函数。 三个函数会以不同的方式返回集合中的数据

    * `iter` - 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍 可以使用。
    * `into_iter` - 会消耗集合。一旦集合被消 耗了，之后就无法再使用，在循环过程中被删除了。
    * `iter_mut` 函数借用集合中的每个元素，从而允许集合被就地修改。

    ```
    //注意 match 的分支中所写的类型不同，这是不同迭代方式的关键 区别。因为类型不同，能够执行的操作当然也不同。
     let vec =vec!["ferry","jeff","jery"];
        for name in vec.into_iter(){
            match name {
                "ferry"=>{println!("hello ferry");}
                _=>{}
            }
        }
        let vec =vec!["ferry","jeff","jery"];
        for name in vec.iter(){
            match name {
                &"ferry"=>{println!("hello ferry");}
                _=>{}
            }
        }
        let mut vec=vec!["ferry","jeff","jery"];
        for name in vec.iter_mut(){
            *name = match *name {
                "ferry"=>"hello",
                _ => *name,
            }
        }
        println!("{:?}",vec);
    ```

  * match 提供支持 ||分割的多个字符匹配和1..=的范围匹配。

    * match 中解构元组： 	

      ```
      let pair = (0, -2);
       match pair {
       	//第一个元素为0，解构的是第二个元素。
       	(0,y)=> 
      ```

    * 解构(destructure) 使用： & 、ref、ref mut(dereference)不一样； 解引用 使用*

      ```
      //i32的引用
      let reference = &4;
      //重点看match是什么类型
       match reference {
       	//match匹配项这里是引用类型
       	//如是将&去掉，val是&i32类型，若是加上&。val是i32
       	&val =>
       }
       // 如果不想用 `&`，需要在匹配前解引用。
       match *reference {
        	//match匹配项这里是值类型
      	 val => 
       }
       let val=10;
       match val{
      	//此时v是 `&i32` 类型
       	ref v => println("{}",v);//这里可以换成*v都是一样的
       	ref mut v => *v ;// 解引用修改值
       }
       
      match 支持卫定语，条件成立才会执行match分支
      let pair=(10,12);
       match pair {
       (x, y) if x == y => println!("These are twins"),
       
       //match 提供了 @ 符号来绑定变量到名称：在=>可以使用变量来访问值
       match age{
      	 n @ 1  ..= 12 => println!("I'm a child of age {:?}", n),
           n @ 13 ..= 19 => println!("I'm a teen of age {:?}", n),
        }
      ```

    * 解构结构体

      ```
      // 解构结构体的成员
      let foo = Foo { x: (1, 2), y: 3 };
      let Foo { x: (a, b), y } = foo;
      println!("a = {}, b = {},  y = {} ", a, b, y);
      // 也可以忽略某些变量
      let Foo { y, .. } = foo;
      println!("y = {}", y);
      ```

    * if let 和while let

      ```
      // `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行
      // 语句块（`{}`）
      //只有number是Some类型才能解构成功，若是number是None，则进入else分支
      if let Some(i) = number {
      	println!("Matched {:?}!", i);
      }else{
      
      }
      //使用if let来匹配枚举类型：
      enum Foo {
          Bar,
          Baz,
          Qux(u32)
      }
      let a = Foo::Bar;
      // 变量 a 匹配到了 Foo::Bar
      if let Foo::Bar = a {
      	println!("a is foobar");
      }
      
      //枚举未注明 #[derive(PartialEq)]，我们也没有为其实现 PartialEq
      //枚举的实例不具有可比性
      if Foo::Bar == a {
      	// ^-- 这就是编译时发现的错误。使用 `if let` 来替换它。
      	println!("a is foobar");
      }
      ```

      ```
      / 这读作：当 `let` 将 `optional` 解构成 `Some(i)` 时，就
      // 执行语句块（`{}`）。否则就 `break`。
      while let Some(i) = optional {
          if i > 9 {
          	println!("Greater than 9, quit!");
         		 optional = None;
          } else {
          	println!("`i` is `{:?}`. Try again.", i);
          	optional = Some(i + 1); //更改值
          }
      // ^ 使用的缩进更少，并且不用显式地处理失败情况。
      }
      ```

##### 函数

当函数依附于对象存在的时候，通过self来访问内部的数据。

```
impl Point {
    // 这是一个静态方法（static method）
    // 静态方法不需要被实例调用
    // 这类方法一般用作构造器（constructor）
    fn origin() -> Point {
        Point { x: 0.0, y: 0.0 }
    }

}    
```

​    `&self` 是 `self: &Self` 的语法糖（sugar），其中 `Self` 是方法调用者自己

`&mut self` 为 `self: &mut Self` 的语法糖

* **闭包**

  也叫做 lambda 表达式或者 lambda，是一种能够捕获周围范围内变量的函数

  闭包的输入和返回类型两者都**可以**自动推导，而输入变量 名**必须**指明。

  || 括起来表示输入参数，{}是可选的。
  * 允许变量捕获（capture）灵活地适应使用场合，既可移动（move）又可 借用（borrow）变量。
  * `|` 之前使用 `move` 会强制闭包取得被捕获变量的所有权。删除 `move` 会导致闭包以不可变方式借用 变量，因此之后变量仍然可用

```
//一般闭包内访问变量都是借用外部的变量。
// 不可复制类型（non-copy type）。
let movable = Box::new(3);

// `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，
// 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动
// （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。
let consume = || {
    println!("`movable`: {:?}", movable);
    mem::drop(movable);
};
//consume只能被调用一次。
//movable=3; 基础类型的话就可以调用多次
```

​	  因为闭包在定义的时候不需要声明变量类型，但是当闭包作为函数的参数的时候，需要说明闭包的参数类型。

- `Fn`：表示捕获方式为通过引用（`&T`）的闭包，`&T` 获取了不可变的引用
- `FnMut`：表示捕获方式为通过可变引用（`&mut T`）的闭包。则可以改变 变量
- `FnOnce`：表示捕获方式为通过值（`T`）的闭包，表示拿到了变量的所有权而非借用。

例如用一个类型说明为 `FnOnce` 的闭包作为参数。这说明闭包可能采取 `&T`，`&mut T` 或 `T` 中的一种捕获方式，但编译器最终是根据所捕获变量在闭包里的使用情况决定捕获 方式。

> 编译器在捕获闭包的手，使用需求的前提下尽量以限制最多的方式捕获。
>
>  `Fn`，那么不允许该闭包通过 `&mut T` 或 `T` 捕获变量

```
//闭包作为参数的时候，闭包必须是泛型的 `F` 必须是泛型的。
fn apply<F> (f :F)
    where F:FnOnce(){
    f();
}
//闭包的输入为i32，返回一个 `i32` 整型的函数。
fn apply_to_3<F> (f: F) ->i32
//这里特别写清楚闭包的输入和输出的参数
    where F:Fn(i32)-> i32{
    f(2)
}
fn main(){
    let greeting="hello";
    let mut farewell="world".to_owned();
    let double=|x| 2*x;
    let print =||{
        println!("i said:{}",greeting);
        farewell.push_str("!!!");
        println!("then i can {}",farewell);
    };
    apply(print);
    println!("{}",apply_to_3(double));
}
```

当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的 变量

```
// 定义一个函数，可以接受一个由 `Fn` 限定的泛型 `F` 参数并调用它。
fn call_me<F: Fn()>(f: F) {
    f()
}
//函数也可以作为参数出入
// 定义一个满足 `Fn` 约束的封装函数（wrapper function）。
fn function() {
    println!("I'm a function!");
}

fn main() {
    // 定义一个满足 `Fn` 约束的闭包。
    let closure = || println!("I'm a closure!");
    
    call_me(closure);
    call_me(function);
}
```

 闭包的泛型中限制，明确了闭包比如从周围获取变量。  因为限制在函数传参的时候，也更容易发现问题。

* **闭包作为返回值**

rust 只支持返回具体（非泛型）的 类型。按照定义，匿名的闭包的类型是未知的，所以只有使用`impl Trait`才能返回一个闭包。

除此之外，还必须使用 `move` 关键字，它表明所有的捕获都是通过值进行的。这是必须 的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。

```
fn create_fn() -> impl Fn() {
    let text = "Fn".to_owned();
    move || println!("This is a: {}", text)
}
```

* 迭代器中的谓词

  ```
  pub trait Iterator {
      // 被迭代的类型。
      type Item;
      // 表明函数的调用者可以被借用和修改，但不会被消耗。
      fn any<F>(&mut self, f: F) -> bool where
          F: FnMut(Self::Item) -> bool {}
          // `FnMut` 就表示闭包只能通过引用捕获变量。把类型为 `T` 的变量作为闭包
          // 的参数不代表闭包会拿走它的值，也可能是拿走它的引用。
  }
  let vec1 = vec![1, 2, 3];
  let vec2 = vec![4, 5, 6];
  
  // 对 vec 的 `iter()` 举出 `&i32`。（通过用 `&x` 匹配）把它解构成 `i32`。
  // 译注：注意 `any` 方法会自动地把 `vec.iter()` 举出的迭代器的元素一个个地
  // 传给闭包。因此闭包接收到的参数是 `&i32` 类型的。
  println!("2 in vec1: {}", vec1.iter()     .any(|&x| x == 2));
  // 对 vec 的 `into_iter()` 举出 `i32` 类型。无需解构。
  println!("2 in vec2: {}", vec2.into_iter().any(| x| x == 2));
  
  let array1 = [1, 2, 3];
  let array2 = [4, 5, 6];
  
  // 对数组的 `iter()` 举出 `&i32`。
  println!("2 in array1: {}", array1.iter()     .any(|&x| x == 2));
  // 对数组的 `into_iter()` 通常举出 `&i32`。
  println!("2 in array2: {}", array2.into_iter().any(|&x| x == 2));
  ```

* 函数式的编程风格

  迭代器和Option都实现了不少函数式的编程风格

  ```
  //输入一个或多个 函数，并且/或者产生一个更有用的函数的函数
  // 函数式的写法
  let sum_of_squared_odd_numbers: u32 =
      (0..).map(|n| n * n)             // 所有自然数取平方
      .take_while(|&n| n < upper) // 取小于上限的
      .filter(|&n| is_odd(n))     // 取奇数
      .fold(0, |sum, i| sum + i); // 最后加起来
  
  // 发散函数，绝不会返回。 它们使用 ! 标记是一个空类型   
  fn foo() -> ! {
      panic!("This call never returns.");
  }
      
  ```

##### 模块

模块之间的可见性（公有（public）或私有（private））：

模块内包含的项：子模块、impl、trait、函数等

* 加上 `pub` 修饰语来重载这一行为。模块中只有公有的（public）项可以从模块外的作用域 访问。

* 结构体的可见层次也是一样的 ，上 `pub` 修 饰语来重载该行为

  ```
  // 将 `deeply::nested::function` 路径绑定到 `other_function`。
  //使得它更容易使用
  use deeply::nested::function as other_function;
  //可以在路径中使用 super （父级）和 self（自身）关键字，从而在访问项时消除 歧义
  ```

##### crate

crate（中文有 “包，包装箱” 之意）是 Rust 的编译单元。模块不会单独编译，当crate中引用模块的时候，才会被编译器插入到crate中参与编译。

crate 可以编译成二进制可执行文件（binary）或库文件（library）

```
rustc 的选项 --crate-type 重载。
rustc --crate-type=lib rary.rs //将rary.rs创建为一个库
rustc executable.rs --extern rary=library.rlib --edition=2018 && ./executable //来使用库
fn main() {
    rary::public_function(); //直接使用库中的函数
    // 报错！ `private_function` 是私有的
    //rary::private_function();
    rary::indirect_access();
}
```

##### cargo

管理库的依赖关系：

\# 二进制可执行文件 cargo new foo # 或者库 cargo new --lib foo

Cargo.toml 是管理本项目的配置文件。 

**构建脚本 ，此文件将在编译包中的任何其他内容之前，优先进行编译和调用。**

```
[package]
...
build = "build.rs" //指定构建脚本，比如代码生成或者需要编译的一些本地代码
//这里 cargo 将在项目目录中优先查找 build.rs 文件
name = "foo"
version = "0.1.0"
authors = ["mark"]

[dependencies]
clap = "2.27.1" # 来自 crates.io
rand = { git = "https://github.com/rust-lang-nursery/rand" } # 来自网上的仓库
bar = { path = "../bar" } # 来自本地文件系统的路径
```

在项目目录中的任何位置（包括子目录！）执行 `cargo build`。 cargo会在需要的时候下载crate。

同一个项目中有两个二进制可执行文件，可以在bin文件夹下放其他的二进制可执行文件。

```
foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
//cargo build --bin my_other_bin  来构建二进制文件下的文件
cargo test
```

##### 属性

属性的功能：

* 条件编译代码
* 设置 crate 名称、版本和类型（二进制文件或库）
* 禁用 [lint](https://en.wikipedia.org/wiki/Lint_(software)) （警告）
* 启用编译器的特性（宏、全局导入（glob import）等）
* 链接到一个非 Rust 语言的库
* 标记函数作为单元测试
* 标记函数作为基准测试的某个部分

\#![crate_attribute] ：表示的全局的属性

\#[crate_attribute] ：表示的作用于本crate或者模块项的属性（少了！）

\#[attribute(key = "value")] ： 属性可以接受参数。

> 模块项： 函数、结构体 impl

* 比如在rust中存在着未使用的函数和变量的时候，就会产生一个编译器的告警：

```
#[allow(dead_code)] //相当于注解一个函数 ，接受dead_code，但是最好是将代码清理掉
```

* **cfg实现条件编译.**

  条件编译可能通过两种不同的操作符实现：

  - `cfg` 属性：在属性位置中使用 `#[cfg(...)]`
  - `cfg!` 宏：在布尔表达式中使用 `cfg!(...)`

  ```
  // 这个函数仅当目标系统是 Linux 的时候才会编译
  #[cfg(target_os = "linux")]
  // 而这个函数仅当目标系统 **不是** Linux 时才会编译
  #[cfg(not(target_os = "linux"))]
  //使用宏来定义不同的编译条件
  if cfg!(target_os = "linux") {
          println!("Yes. It's definitely linux!");
      } else {
  ```

`target_os` 是由 `rustc` 隐式地提供的，但是自定的类型必须使用rustc --cfg 

```
#[cfg(some_condition)]
fn print(){
	//
}
rustc --cfg some_condition custom.rs && ./custom
```

##### 泛型

是否为泛型，比较重要的当前是否接受的是一个`类型参数`，还是一个具体的类型。 

```rust
fn gen_spec_t(_s: SGen<A>) {} //这个函数不是泛型函数 
//其他语言中将泛型声明在函数名的前面
fn generic<T>(_s: SGen<T>) {} 
//impl 声明泛型
//	`<T>` 必须在类型之前写出来，以使类型 `T` 代表泛型。
impl <T> GenericVal<T> {}
//泛型的trait
trait DoubleDrop<T> {
    // 定义一个调用者的方法，接受一个额外的参数 `T`，但不对它做任何事。
    fn double_drop(self, _: T);
}
```

* **泛型的约束**

  ```rust
  //T必须为Display类型
  fn printer<T: Display>(t: T) {
  }
  fn printer<T>(t:T)
     where T:Display{ //某些情况下也可使用 where 分句来形成约束，这拥有更好的表现力。
  }
  //泛型的约束中可以支持空的Trait
  trait A{} 
  // 泛型的类型约束要是trait，否则的话会报错
  fn print<T: A>()
  ```

* 泛型的多重约束

  ```
  //可以用 + 连接。和平常一样，类型之间使用 , 隔开。
  fn compare_prints<T: Debug + Display>(t: &T) {
      println!("Debug: `{:?}`", t);
      println!("Display: `{}`", t);
  }
  //约束的类型必须是同时实现了Display和Debug的类型，若是传入的类型是array或者vector 类没有实现Display 的类型会报错
  
  ```

* **where限制语句** 

  从句可以用于任意类型的限定，而不局限于类型参数本身。

  ```rust
  //where 和
  fn impl <A: traitA+traiB,B: traitC+traitD>  <A,B> for Struct//
  //等价于
  fn impl<A,B> for Struct where
  A: traitA+traitB,
  B: traitC+traitD{}
  ```

* `newtype` 惯用法

  ```
  //这个不太理解，不同类型之间正确定义类型
  #[derive(Debug, Clone, Copy)]
  struct Year(u32);
  #[derive(Debug)]
  struct Days(u32);
  impl Year{
  	//Days和Year的相互转换
      fn to_days(y :&Year)-> Days{
          return Days(y.0*365);
      }
  }
  impl Days{
      fn to_years(d :&Days) ->Year{
          return Year(d.0/365);
      }
  }
  fn printYear(y :&Year){
      print!("{:?}",y);
  }
  fn main(){
      let y=Year(10);
      let day=Year::to_days(&y);
      printYear(&y);
      printYear(& Days::to_years(&day));
  }
  ```

* 在使用泛型的trait的时候，若是该泛型作为参数的时候需要指明泛型的参数

  ```
  //泛型的trait
  trait Contains<A, B> {
      fn contains(&self, _: &A, _: &B) -> bool; // 显式地要求 `A` 和 `B`
      fn first(&self) -> i32; // 未显式地要求 `A` 或 `B`
      fn last(&self) -> i32;  // 未显式地要求 `A` 或 `B`
  }
  //容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。
  fn difference<A, B, C>(container: &C) -> i32 where
  	//这里必须要指明泛型方法中的泛型trait的是哪些
      C: Contains<A, B> {
      container.last() - container.first()
  }
  ```

* 关联类型

  一种将类型占位符与 trait 联系起来的 做法，这样 trait 中的方法签名中就可以使用这些占位符类型。trait 的实现会指定在 该实现中那些占位符对应什么具体类型。

  ```rust
  / `A` 和 `B` 在 trait 里面通过 `type` 关键字来定义。
  // （注意：此处的 `type` 不同于为类型取别名时的 `type`）。
  trait Contains {
      type A;
      type B;
      // 这种语法能够泛型地表示这些新类型。
      fn contains(&self, &Self::A, &Self::B) -> bool;
  }
  //不使用关联类型和使用关联类型
  fn difference<A, B, C>(container: &C) -> i32 where
  	//这里必须要指明泛型方法中的泛型trait的是哪些
      C: Contains<A, B> {}
  //使用关联类型    
  fn difference<C: Contains>(container: &C) -> i32 { ... }
  //在trait中实现中指定具体是什么类型。
  impl Cons for Container{
      type A=i32;
      type B=i32;
      fn contains(&self,a :&Self::A,b :&Self::B) ->bool{
          if *a==self.0 && *b==self.1 {return true;}
          else {return false;}
      }
      fn first(&self) ->i32 { self.0}
      fn last(&self) ->i32 { self.1}
  }
  fn diff<C :Cons>(cons: &C) ->i32{
      cons.first()-cons.last()
  } 
  ```

* 虚类型参数

  是一种在静态编译的时候进行检查的类型参数。

  ```rust
  use std::marker::PhantomData;
  // 这个虚元组结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。
  #[derive(PartialEq)] // 允许这种类型进行相等测试（equality test）。
  //A会分配存储空间，但是B不会
  struct PhantomTuple<A, B>(A,PhantomData<B>);
  // 被指定为 `<char, f32>` 的 `PhantomTuple` 类型。
  let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);
  // 被指定为 `<char, f64>` `PhantomTuple` 类型。
  let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);
  //tuple1==tuple2因为类型不匹配会出现报错。
  
  
  //进行单元检查
  `<RHS = Self>` 表示 RHS 的默认值
  // 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。
  pub trait Add<RHS = Self> {
      type Output;
      fn add(self, rhs: RHS) -> Self::Output;
  }
  
  
  use std::ops::Add;
  use std::marker::PhantomData;
  
  /// 创建空枚举类型来表示单位。
  #[derive(Debug, Clone, Copy)]
  enum Inch {}
  #[derive(Debug, Clone, Copy)]
  enum Mm {}
  /// `Length` 是一个带有虚类型参数 `Unit` 的类型，
  /// 而且对于表示长度的类型（即 `f64`）而言，`Length` 不是泛型的。
  ///
  /// `f64` 已经实现了 `Clone` 和 `Copy` trait.
  #[derive(Debug, Clone, Copy)]
  struct Length<Unit>(f64, PhantomData<Unit>);
  
  /// `Add` trait 定义了 `+` 运算符的行为。
  impl<Unit> Add for Length<Unit> {
       type Output = Length<Unit>;
  
      // add() 返回一个含有和的新的 `Length` 结构体。
      fn add(self, rhs: Length<Unit>) -> Length<Unit> {
          // `+` 调用了针对 `f64` 类型的 `Add` 实现。
          Length(self.0 + rhs.0, PhantomData)
      }
  }
  //重点就是： 因为Length中虚类型参数不一样所以，不能够支持直接相加和比较。
  fn main() {
      // 指定 `one_foot` 拥有虚类型参数 `Inch`。
      let one_foot:  Length<Inch> = Length(12.0, PhantomData);
      // `one_meter` 拥有虚类型参数 `Mm`。
      let one_meter: Length<Mm>   = Length(1000.0, PhantomData);
  
      // `+` 调用了我们对 `Length<Unit>` 实现的 `add()` 方法。
      //
      // 由于 `Length` 了实现了 `Copy`，`add()` 不会消耗 `one_foot`
      // 和 `one_meter`，而是复制它们作为 `self` 和 `rhs`。
      let two_feet = one_foot + one_foot;
      let two_meters = one_meter + one_meter;
  
      // 加法正常执行。
      println!("one foot + one_foot = {:?} in", two_feet.0);
      println!("one meter + one_meter = {:?} mm", two_meters.0);
  
      // 无意义的运算当然会失败：
      // 编译期错误：类型不匹配。
      //let one_feter = one_foot + one_meter;
  }
  
  ```

##### 作用域规则

什么时候借用是合法的、什么时候资源可以释放、以及 变量何时被创建或销毁。

rust强制实行，资源被分配的时候就应该被初始化。所以任何对象在离开作用域时，它的析构 函数（destructor）就被调用

```
Box::new()//在堆上创建的内存，只要离开作用域就会被释放其空间。
```

 析构函数通过实现**Drop trait**，只要那些需要析构逻辑的提供析构就行。

* 所有权和移动

  因为变量需要释放它们的资源，所有只能有一个变量有资源的所有权。

  在进行赋值（`let x = y`）或通过值来传递函数参数（`foo(x)`）的时候。 资源的所有权发生了变动，**移动**。

  移动以后原来资源的所有者的变量就不能够被调用，可避免悬挂指针。

```
let a=Box::new(10);
let b = a;
// 把 `a` 的指针地址（而非数据）复制到 `b`。现在两者都指向
// 同一个堆分配的数据，但是现在是 `b` 拥有它。    
// 报错！`a` 不能访问数据，因为它不再拥有那部分堆上的内存。
```

* 部分移动

  `by-move` 和 `by-reference` 模式

  ```
  fn main() {
      #[derive(Debug)]
      struct Person {
          name: String,
          age: u8,
      }
      let person = Person {
          name: String::from("Alice"),
          age: 20,
      };
      // `name` 从 person 中移走，但 `age` 只是引用
      let Person { name, ref age } = person;
     println!("The person's age is {}", age);
      println!("The person's name is {}", name);
      // 报错！部分移动值的借用：`person` 部分借用产生
      println!("The person struct is {:?}", person);
      // `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用
      println!("The person's age from person struct is {}", person.age);
  }
  
  ```

* **借用**

  * 实现这点，Rust 使用 了**借用**（borrowing）机制。对象可以通过引用（`&T`）来传递，从而取代通过 值（`T`）来传递。由编译器来保证被引用的对象不能够被销毁，被引用的对象总是有效的。

  * 可变数据可以使用 `&mut T` 进行可变借用。这叫做**可变引用**

    **不允许以后可变变量借用一个不可变量**

    ```
    //若是没有copy trait的话， Book的赋值操作会带来所有权的move的问题。
    #[derive(Debug,Copy,Clone)]
    struct Book{
        // `&'static str` 是一个对分配在只读内存区的字符串的引用
        title: &'static str,
        year : u32,
    }
    fn borrow(book  :&Book) {
        println!("i am immutable borrow reference: {}-{}",book.title,book.year);
    }
    fn new_editor(book :&mut Book){
        book.year=2014;
        println!("i am mutable borrow reference:{}-{}",book.title,book.year);
    }
    fn main(){
       let book=Book{
           title:"holly peter",
           year:1972,
       };
       let mut mutable_book=book;
       borrow(&book);
        borrow(&mutable_book);
        new_editor(&mut mutable_book);
        //new_editor(&mut book);
    }
    ```

* 别名使用

  同一时间内只允许**一次**可变借用。仅当最后一次使用可变引用**之后**，原始数据才可以再次借用。

  ```rust
  fn main(){
     let mut  book=Book{
         title:"holly peter",
         year:1972,
     };
      let immutable_book2=& book;
      // 不可变的引用不再用于其余的代码，因此可以使用可变的引用重新借用。
      //let mut mutable_book=&mut book;  //这里报错
      println!("title:{}, year:{}",immutable_book2.title,immutable_book2.year);
      let mut mutable_book=&mut book;
      // 通过可变引用来修改数据
      mutable_book.title="double city";
      mutable_book.year=1992;
      println!("title:{}, year:{}",mutable_book.title,mutable_book.year);
  
      // 报错！不能再以不可变方式来借用 `point`，因为它当前已经被可变借用。
      let title = &book.title; //报错：immutable borrow occurs here
      // TODO ^ 试一试去掉此行注释
  
      // 报错！无法打印，因为 `println!` 用到了一个不可变引用。
      //println!("title is {}", book.title); //报错：immutable borrow occurs here
      // TODO ^ 试一试去掉此行注释
  
      println!("title:{}, year:{}",mutable_book.title,mutable_book.year);
  
      // 可变引用不再用于其余的代码，因此可以重新借用
      let new_borrowed_point = &book;
  }
  ```

* **ref关键字的使用**

  `ref` 关键字可用来创建结构体/元组的 字段的引用

  ```rust
  let c = 'Q';
  // 赋值语句中左边的 `ref` 关键字等价于右边的 `&` 符号。
  let ref ref_c1 = c;
  let ref_c2 = &c;
  #[derive(Clone, Copy)]
  struct Point { x: i32, y: i32 }
  //结构一个结构体ref_to_x 指向x的引用
  let Point { x: ref ref_to_x, ref mut mut_ref_to_y } = point;
  *mut_ref_to_y+=1;//通过解构引用来改变值
  ```

##### 生命周期

生命周期是一种概念，编译器用它来保证所有的引用都是有效的。

要求参数的生命周期更长因为，防止在使用该crate项的时候出现悬空指针的报错的问题。

**生命周期和作用域：** 一般的变量若是在作用域结束的时候被销毁，所以生命周期也结束。

* **显示的标识引用的生命周期：**

  ```
  //显式的生命周期标记来明确引用的有效时间应该持续多久
  foo<'a>
  // `foo` 带有一个生命周期参数 `'a`
  //foo 的生命周期不能超出 'a 和 'b 中任一个的周期。
  //'a表示的生命周期至少要和foo一样长
  foo<'a>(){
  let _x = 12;
  // 报错：_x 的生命周期不够长
  //let y: &'a i32 = &_x;
  // 在函数内部使用生命周期 'a 作为显式类型标注将导致失败，因为 &_x 的
  // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。
  }
  ```

* 带上函数签名的一些限制

  ```
  //生命周期标识，只约束的是引用。
  fn test<'a>(t : i32) ->i32//对于值类型的没有约束
  //带上生命周期的函数签名有一些限制：
  fn add_one<'a>(x: &'a mut i32) {
      *x += 1;
  }
  //fn invalid_output<'a>() -> &'a String { &String::from("foo") }
  // 上面代码是无效的：`'a` 存活的时间必须比函数的长。
  // 这里的 `&String::from("foo")` 将会创建一个 `String` 类型，然后对它取引用。
  // 数据在离开作用域时删掉，返回一个指向无效数据的引用。
  fn add_one<'a>(x: &i32) { // 报错，函数声明了需要一个生命周期标识，引用必须带上生命周期标识
  ```

* 结构体和trait的生命周期标识

  ```
  //这里的两个引用都必须比这个结构体长寿。
  #[derive(Debug)]
  struct NamedBorrowed<'a> {
      x: &'a i32,
      y: &'a i32,
  }
  // 给 impl 标注生命周期。
  impl<'a> Default for NamedBorrowed<'a> {
      fn default() -> Self {
          Self {
              x: &10,
          }
      }
  }
  ```

* 约束

  1. `T: 'a`：在 `T` 中的**所有**引用都必须比生命周期 `'a` 活得更长。
  2. `T: Trait + 'a`：`T` 类型必须实现 `Trait` trait，并且在 `T` 中的**所有**引用 都必须比 `'a` 活得更长。

  ```
  #[derive(Debug)]
  struct Ref<'a, T: 'a>(&'a T);
  // `Ref` 包含一个指向泛型类型 `T` 的引用，其中 `T` 拥有一个未知的生命周期
  // `'a`。`T` 拥有生命周期限制， `T` 中的任何*引用*都必须比 `'a` 活得更长。另外
  // `Ref` 的生命周期也不能超出 `'a`。
  
  // 这里接受一个指向 `T` 的引用，其中 `T` 实现了 `Debug` trait，并且在 `T` 中的
  // 所有*引用*都必须比 `'a'` 存活时间更长。另外，`'a` 也要比函数活得更长。
  fn print_ref<'a, T>(t: &'a T) where
      T: Debug + 'a {
      println!("`print_ref`: t is {:?}", t);
  }
  ```

* 生命周期声明

  一个较长的生命周期可以强制转成一个较短的生命周期

  ```
  // `<'a: 'b, 'b>` 读作生命周期 `'a` 至少和 `'b` 一样长。
  // 在这里我们我们接受了一个 `&'a i32` 类型并返回一个 `&'b i32` 类型，这是
  // 强制转换得到的结果。
  fn choose_first<'a: 'b, 'b>(first: &'a i32, _: &'b i32) -> &'b i32 {
      first
  }
  // 当接收到生命周期中有一个短的生命周期的时候，另外一个变量的生命周期会被强制转换成短生命周期
  fn multiply<'a>(first: &'a i32, second: &'a i32) -> i32 {
      first * second
  }
  fn main(){
   let first = 2; // 较长的生命周期
      {
        let second = 3; // 较短的生命周期        
     	  println!("The product is {}", multiply(&first, &second));
      };
  }
  ```

* static

  `'static` 生命周期是可能的生命周期中最长的，它会在整个程序运行的时期中 存在。`'static` 生命周期也可被强制转换成一个更短的生命周期

  拥有static的类型，把数据保存在可执行文件的只读内存区：

  * 使用 `static` 声明来产生常量
  * 产生一个拥有 `&'static str` 类型的 `string` 字面量。

  ```
  // 产生一个拥有 `'static` 生命周期的常量。
  static NUM: i32 = 18;
  fn coerce_static<'a>(_: &'a i32) -> &'a i32 {
      &NUM
  }
  //Num会被转换成和返回值有相同生命周期。
  let coerced_static = coerce_static(&lifetime_num);
   
   // 产生一个 `string` 字面量并打印它：
   let static_string = "I'm in read-only memory";
   println!("static_string: {}", static_string);
  // 当 `static_string` 离开作用域时，该引用不能再使用，不过
  // 数据仍然存在于二进制文件里面。
  ```

* **省略：**

  隐式添加生命周期的过程称为省略。有些生命周期的模式太常用了，所以借用检查器将会隐式地添加它们以减少程序输入量 和增强可读性

  ```
  // `elided_input` 和 `annotated_input` 事实上拥有相同的签名，
  // `elided_input` 的生命周期会被编译器自动添加：
  fn elided_input(x: &i32) {
      println!("`elided_input`: {}", x)
  }
  fn annotated_input<'a>(x: &'a i32) {
      println!("`annotated_input`: {}", x)
  }
  
  ```

##### Trait

`trait` 是对未知类型 `Self` 定义的方法集。

```
trait Animal {
    // 静态方法签名；`Self` 表示实现者类型（implementor type）。
    fn new(name: &'static str) -> Self;
    // 实例方法签名；这些方法将返回一个字符串。
    fn name(&self) -> &'static str;
    fn noise(&self) -> &'static str;
}
//Sheep是Animal的实现struct
let mut dolly :Sheep= Animal::new("Dolly");
//若是将类型移除会报错，cannot infer type
```

* 派生：

  通过 `#[derive]` [属性](https://rustwiki.org/zh-CN/rust-by-example/attribute.html)，编译器能够提供某些 trait 的基本实现。

  - 比较 trait: [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), [`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html), [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)
  - [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), 用来从 `&T` 创建副本 `T`。
  - [`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html)，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。
  - [`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html)，从 `&T` 计算哈希值（hash）。
  - [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), 创建数据类型的一个空实例。
  - [`Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html)，使用 `{:?}` formatter 来格式化一个值。

* 使用dyn 返回trait

  Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。

  想要返回像 `Animal` 那样的的 trait，则不能编写返回 `Animal` 的函数，因为其不同的实现将需要不同的内存量。

  函数返回一个包含一些 `Animal` 的 `Box`。`box` 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 `Animal`。

  每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的 trait 指针，则需要使用 `dyn` 关键字编写返回类型，例如 `Box<dyn Animal>`

* 运算符重载

  rust中许多运算符都实现特定的trait来重载。这之所以可行，是因为运算符就是方法调用的语法糖。例 如，`a + b` 中的 `+` 运算符会调用 `add` 方法（也就是 `a.add(b)`）。add 是Trait方法的实现的一部分。

  ```
  struct FooBar;
  struct BarFoo;
  // 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。
  impl ops::Add<Bar> for Foo {
      type Output = FooBar;
      //Bar类型是右操作数。
      fn add(self, _rhs: Bar) -> FooBar {
          println!("> Foo.add(Bar) was called");
          FooBar
      }
  }
  //不服从交换律
  //若是Bar+Foo类型操作就会出现报错
  ```

* **Drop trait：**

  [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) trait 只有一个方法：`drop`，当对象离开作用域时会自动调用该 方法。`Drop` trait 的主要作用是释放实现者的实例拥有的资源。

  自定义类型需要手动实现 Drop trait。

* Iterator trait

  `Iterator` trait 用来对集合（collection）类型（比如数组）实现迭代器。

  这个 trait 只需定义一个返回 `next`（下一个）元素的方法，这可手动在 `impl` 代码块 中定义，或者自动定义（比如在数组或区间中）。

  为方便起见，`for` 结构会使用 [`.into_iterator()`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) 方法将一些集合类型 转换为迭代器。

  ````rust
  let arr=[1,2,3,4];
  //`iter` 方法对数组/slice 产生一个 `Iterator`。
  for val in arr.iter(){ 
  }
  // `for` 遍历 `Iterator` 直到返回 `None`，
  // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。      
  for i in 0..3 {
      println!("> {}", i);
  }
  ````

* impl trait 返回值

  ```
  //每个闭包都有自己未命名的具体类型。在使用 impl Trait 语法之前，必须在堆上进行分配才能返回闭包。
  // 返回一个将输入和 `y` 相加的函数
  fn make_adder_function(y: i32) -> impl Fn(i32) -> i32 {
      let closure = move |x: i32| { x + y };
      closure
  }
  ​```
  因为闭包类型没有名称，所以如果函数返回带闭包的迭代器，则无法写出显式的返回类型。但是有了 impl Trait，你就可以轻松地做到这一点：
  //返回map和filter的迭代器
  fn double_positives<'a>(numbers: &'a Vec<i32>) -> impl Iterator<Item = i32> + 'a {
      numbers
          .iter()
          .filter(|x| x > &&0)
          .map(|x| x * 2)
  }
  ```

* Clone Trait

  默认的赋值操作`=`是进行move操作（资源转移），实现了clone trait可以实现资源的复制

  ```
  // 不含资源的单元结构体
  #[derive(Debug, Clone, Copy)]
  struct Nil;
  // 一个包含资源的结构体，它实现了 `Clone` trait
  #[derive(Clone, Debug)]
  struct Pair(Box<i32>, Box<i32>);
  
  fn main() {
      // 实例化 `Nil`
      let nil = Nil;
      // 复制 `Nil`，没有资源用于移动（move）  **** 重点1 ****
      let copied_nil = nil;
      // 两个 `Nil` 都可以独立使用 
      println!("original: {:?}", nil);
      println!("copy: {:?}", copied_nil);
  
      // 实例化 `Pair`
      let pair = Pair(Box::new(1), Box::new(2));
      println!("original: {:?}", pair);
  
      // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源
      let moved_pair = pair;  //**** 重点2 ****
      println!("copy: {:?}", moved_pair);
  
      // 报错！`pair` 已失去了它的资源。
      //println!("original: {:?}", pair);
      // 试一试 ^ 取消此行注释。
  
      // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。
      let cloned_pair = moved_pair.clone();  //**** 重点3 ****
      // 使用 std::mem::drop 来销毁原始的 pair。
      //drop(moved_pair);
      // 报错！`moved_pair` 已被销毁。
      println!("copy: {:?}", moved_pair);
      // 试一试 ^ 将此行注释掉。
      // 由 .clone() 得来的结果仍然可用！
      println!("clone: {:?}", cloned_pair);
  }
  
  ```

   这点比较恼人，要么都统一使用clone来显示的复制，没有资源的是复制，有资源的是move操作。

* 父trait

  Rust 没有“继承”，但是您可以将一个 trait 定义为另一个 trait 的超集（即父 trait）

  ```
  trait Person {
      fn name(&self) -> String;
  }
  // Person 是 Student 的父 trait。
  // 实现 Student 需要你也 impl 了 Person。
  trait Student: Person {
      fn university(&self) -> String;
  }
  // CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。
  // 实现 CompSciStudent 需要你同时 impl 了两个父 trait。
  trait CompSciStudent: Programmer + Student {
  ```

* 消除重叠的trait

  结构体实现的多个trait中，存在着重叠的方法名和不同的返回值的时候。

  了消除它们之间的歧义，我们必须使用完全限定语法

  ```
  //from 是From struct的实例
  //AgeWidget是From实现的trait
  let age = <Form as AgeWidget>::get(&form);
  ```

##### 错误处理

* 显式的 `panic` 主要用于测试，以及处理不可恢复的错误。

* `Option` 类型是为了值是可选的、或者**缺少值**并不是错误的情况准备的。

  * 当处理 `Option` 时，`unwrap` 可用于原型开发，也可以用于能够确定 `Option` 中一定有值 的情形。然而 `expect` 更有用，因为它允许你指定一条错误信息，以免万一还是出现 了错误。
  * 当错误有可能发生，且应当由调用者处理时，使用 `Result`。你也可以 `unwrap` 然后 使用 `expect`

* Option

   让编译器辨别没有，None表示找不相应的元素。通过 `match` 显式地处理，或使用 `unwrap` 隐式地处理。隐式处理要么 返回 `Some` 内部的元素，要么就 `panic`。

  ```
  fn next_birthdy(cur :&Option<u8>) -> Option<String>{
  	//对cur?表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 None
  	let x :u8= cur?;
  	Some(format!("next year :{}",x))
  }
  //例如：
  struct Person {
      job: Option<Job>,
  }
  #[derive(Clone, Copy)]
  struct Job {
      phone_number: Option<PhoneNumber>,
  }
  #[derive(Clone, Copy)]
  struct PhoneNumber {
      area_code: Option<u8>,
      number: u32,
  }
  //自己写的话需要很多行代码
  self.job?.phone_number?.area_code
  ```

* map组合算子： 以模块化的风格来管理控制流

  `Option` 有一个内置方法 `map()`，这个组合算子可用于 `Some -> Some` 和 `None -> None` 这样的简单映射。多个不同的 `map()` 调用可以串起来，这样更加灵活。

  map实现从Option 转换成Option。map同时是值传递，会消耗原始值。
  
  ```
  // 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。
  fn process(food: Option<Food>) -> Option<Cooked> {
      food.map(|f| Peeled(f))
          .map(|Peeled(f)| Chopped(f))
          .map(|Chopped(f)| Cooked(f))
}
  ```

  为了防止map导致出现嵌套形式 `Option<Option<T>>`，多层串联调用的混乱。

  `and_then()` 使用被 `Option` **包裹的值来调用其输入函数并返回结果（注意这里不是将Option作为函数参数）**。 如果 `Option` 是 `None`，那么它返回 `None`。
  
  ```
  fn sq(x: u32) -> Option<u32> { Some(x * x) }
  Some(2).and_then(sq).and_then(sq);
  ```
  
* Result是比option更丰富的版本。

   * unwrap()`，它要么举出元素 `T`，要么就 `panic

   * Result通过判断返回的结果是否为Err，传递错误给调用者，由调用者进行错误的处理。

   * Result的？,在出现Err分支，提前返回Err(err)

     ```rust
      let i: () = "t".parse::<i32>(); //将字符串转换失败，报错，为了确定是什么样的错误，
      //使用该技巧编译器告诉你什么类型错误。
      Result<i32, std::num::ParseIntError>，在编写函数的时候确定好错误。
     // 写match来判断函数的返回类型Result
     //下面的写法可以减少match的书写
      first_number_str.parse::<i32>().and_then(|first_number| {
             second_number_str.parse::<i32>().map(|second_number| first_number * second_number)
         })
         
     // 为带有错误类型 `ParseIntError` 的 `Result` 定义一个泛型别名。
     type AliasedResult<T> = Result<T, ParseIntError>;
     //返回值，直接使用 AliasedResult<i32> 
     
     //只是想 unwrap 且避免产生 panic，只想取出里面的数据而避免panic,使用?，在放生的错误的时候，返回错误
     fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {
         //first_number_str.parse::<i32>().unwrap()
         let first_number = first_number_str.parse::<i32>()?;
         let second_number = second_number_str.parse::<i32>()?;
     
         Ok(first_number * second_number)
     }
     ```

   * Option和Result的相互转换

     ```rust
     fn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {
         vec.first().map(|first| {
             first.parse::<i32>().map(|n| 2 * n)
         })
     }
     fn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
         let opt = vec.first().map(|first| {
             first.parse::<i32>().map(|n| 2 * n)
         });
         //使用?不想再继续处理错误，交换Option和Result
         opt.map_or(Ok(None), |r| r.map(Some))
     }
     ```

   * 自定义错误

     将多种错误视为一种错误。

     ```rust
     //自定义错误实现Error trait可以被其他的Error所包括
     fn double_first(vec: Vec<&str>) -> Result<i32> {
         vec.first()
            // 把错误换成我们的新类型。
            .ok_or(DoubleError)
            .and_then(|s| {
                 s.parse::<i32>()
                     // 这里也换成新类型。
                     .map_err(|_| DoubleError)
                     .map(|i| 2 * i)
             })
     }
     // 为 `Box<error::Error>` 取别名。
     type Result<T> = std::result::Result<T, Box<error::Error>>;
     ```

     如果又想写简单的代码，又想保存原始错误信息，使用错误装箱。`Box<Error>` 的转换。

   * 

##### 标准类型库的使用

使用Box可以将值**装箱**，是一个智能指针，指向堆分配 的 `T` 类型的值。当箱子离开作用域时，它的析构函数会被调用，内部的对象会被 销毁，堆上分配的内存也会被释放。`*` 运算符进行解引用；这会移除掉一层装箱

Box的指针是在栈上分配内存的。

* Vector: 动态数组

  ```rust
  //vector的几种初始化方式： 
  // 迭代器可以被收集到 vector 中
   let collected_iterator: Vec<i32> = (0..10).collect();
  let mut xs = vec![1i32, 2, 3];
  了他
  let mut xs =Vec::new();
      xs.push(4);
  //通过下标访问元素和pop弹出元素
   println!("Second element: {}", xs[1]);
  // `pop` 移除 vector 的最后一个元素并将它返回
  println!("Pop last element: {:?}", xs.pop());
  //可迭代vector
  for (i, x) in xs.iter().enumerate() {
  //迭代的时候同时修改元素
  // 多亏了 `iter_mut`，可变的 `Vector` 在迭代的同时，其中每个值都能被修改
  for x in xs.iter_mut() {    
  ```

* Rust 中有两种字符串类型：`String` 和 `&str`。

  `String` 被存储为由字节组成的 vector（`Vec<u8>`），但保证了它一定是一个有效的 UTF-8 序列。String 是堆分配内存。	

  `&str` 是一个总是指向有效 UTF-8 序列的切片（`&[u8]`），可以用来查看String的内容。

  ```
  String::from()//在堆上分配内幕才能
  fn main() {
      let str :&'static str="the quick brown fox jumps over the lazy dog";
      for word in str.split_whitespace().rev(){
          println!(">{}",word);
      }
      let mut chars:Vec<char>=str.chars().collect();
      chars.sort();
      chars.dedup();
      println!("chars:{:?}",chars);
      // 创建一个空的且可增长的 `String`
      let mut string = String::new();
      for c in chars {
          // 在字符串的尾部插入一个字符
          string.push(c);
          // 在字符串尾部插入一个字符串
          string.push_str(", ");
      }
      let chars_to_trim: &[char] = &[' ', ','];
      let trimmed_str=str.trim_matches(chars_to_trim);
      println!("trimmed_str: {}",trimmed_str);
  }
  
  //显示原始字符串，特别是当需要被转义的字符太多的时候，这种方式就特别适用
  let raw_str = r"Escapes don't work here: \x3F \u{211D}";
  println!("{}", raw_str); 
  // 如果你要在原始字符串中写引号，请在两边加一对 #
  let quotes = r#"And then I said: "There is no escape!""#;
  println!("{}", quotes);
  // 如果字符串中需要写 "#，那就在定界符中使用更多的 #。
  // 可使用的 # 的数目没有限制。
  let longer_delimiter = r###"A string with "# in it. And even "##!"###;
  println!("{}", longer_delimiter);
  ```

* Result

  ```
  enum MathErr{
      DivideZero,
      NegativeLog,
      NegativeSquareRoot,
  }
  type MathResult=Result<f64,MathErr>;
  fn divide(x :f64,y: f64) -> MathResult{
      if y==0.0 {
          return Err(MathErr::DivideZero);
      }else{
          return Ok(x/y);
      }
  }
  fn square(x:f64)->MathResult{
      if x<0.0 {
          return Err(MathErr::NegativeSquareRoot);
      }else{
          return Ok(x.sqrt());
      }
  }
  fn log(x:f64)->MathResult{
      if x<0.0 {
          return Err(MathErr::NegativeLog);
      }else{
          return Ok(x.ln());
      }
  }
  fn _op(x:f64,y:f64) ->MathResult{
      let div=divide(x,y)?;
      let logN=log(div)?;
      square(logN)
  }
  fn op(x:f64,y:f64){
      match _op(x,y) {
          Ok(val)=> println!("result: {}",val),
          Err(err)=> match err {
              MathErr::NegativeLog=> {println!("logarithm of negative number")},
              MathErr::DivideZero=> println!("division by zero"),
              MathErr::NegativeSquareRoot=>println!("square root of negative number"),
          }
      }
  }
  ```

* HashMap

  `HashMap::with_capacity(unit)` 创建具有一定初始容量的 HashMap，也 可以使用 `HashMap::new()` 来获得一个带有默认初始容量的 HashMap

  * hash.get(&ref) ： 接受一个对key的引用，返回Option

  * 实现了 `Eq` 和 `Hash` trait 的类型都可以充当 `HashMap` 的键。（str \int \bool）
  * 注意到 `f32` 和 `f64` **没有**实现 `Hash`，浮点数存在精度误差
  * 对于集合类：若 `T` 实现了 `Hash`，则 `Vec<T>` 也实现了 `Hash`，包含的成员都实现了Hash，集合也实现了Hash
  * **需要被特别注意的：HashMap的insert操作导致所有权的移动，key和value**

* Hashset

  - `union`（并集）：获得两个集合中的所有元素（不含重复值）。

  - `difference`（差集）：获取属于第一个集合而不属于第二集合的所有元素。

  - `intersection`（交集）：获取同时属于两个集合的所有元素。

  - `symmetric_difference`（对称差）：获取所有只属于其中一个集合，而不同时属于 两个集合的所有元素。

    ```
     let mut a :HashSet<i32>=vec![1,2,3].into_iter().collect();
     let mut b :HashSet<i32>=vec![3,4].into_iter().collect();
     //assert!(a.contains(&4));
     //assert!(b.insert(4),"4 is already in set b");
     b.insert(5);
     println!("Union: {:?}",a.union(&b).collect::<Vec<&i32>>());
     println!("Diff: {:?}",a.difference(&b).collect::<Vec<&i32>>());
     println!("intersection: {:?}",a.intersection(&b).collect::<Vec<&i32>>());
     println!("symmetric_difference: {:?}",a.symmetric_difference(&b).collect::<Vec<&i32>>());
    ```

##### 测试

```
//单元测试一般放到这个模块中
#[cfg(test)]
mod test{
	#[test]// 单元测试函数
	fn test_func();
}
//
cargo test test_func()//测试特定的函数，若是给出部分的名字，他会同时运行多个测试用例
#[ignore] 赋予测试以排除某些测试
#[should_panic] 这个属性接受可选参数 expected = 以指定 panic 时的消息。这个标签会引发panic
```

**rust中的引用和指针**

rust中让人比较困惑的是： 什么使用& 什么使用使用* 。 比如我们在实现trait的方法中调用像是&self这样的变量。

生命周期会赋值，比如在函数调用的时候会有生命周期的赋值。

迭代器还得再研究。